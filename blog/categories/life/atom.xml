<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Life | Blog of Ditsing]]></title>
  <link href="http://www.ditsing.com/blog/categories/life/atom.xml" rel="self"/>
  <link href="http://www.ditsing.com/"/>
  <updated>2015-10-14T07:51:56+11:00</updated>
  <id>http://www.ditsing.com/</id>
  <author>
    <name><![CDATA[ditsing]]></name>
    <email><![CDATA[ditsing@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[面试投行]]></title>
    <link href="http://www.ditsing.com/blog/2015/10/15/mian-shi-tou-hang/"/>
    <updated>2015-10-15T09:27:47+11:00</updated>
    <id>http://www.ditsing.com/blog/2015/10/15/mian-shi-tou-hang</id>
    <content type="html"><![CDATA[<p>从今年年初我就一直在留意 Google 之外的工作机会。倒不是因为我不喜欢在 Google 工作，而是因为人有时候会幻想，幻想自己跳个槽就能升职加薪走上人生巅峰；有时候也会好奇自己现在在市场上还值多少钱。恰好我经常会收到 LinkedIn 私信，问我有没有兴趣换工作。有些邀请根本就是群发的，跟我的经历一点关系都没有；也有那么几个来自有潜力的创业公司，比如某个做发裸照的应用的公司。今年七月份的时候我收到一封私信，声称他们在帮一个跨国 “Prop Firm” 招 “technical” 人才。我花了很久才 Google 到 Prop Firm 是投资银行的简称。以前经常在某乎上看到投行的实习生晒工资，我突然感到很有兴趣，升职加薪的欲望在心里蠢蠢欲动。</p>

<!-- more -->


<p>于是我就以热情的语气回了邮件，并号称希望换工作的理由是 “believe I can do something more”。很快猎头就给我打过来了电话，介绍了一下这个跨国公司和要招聘的岗位。我问期望薪水有多高，我想要 160K 一年行不行。猎头打哈哈说当然有可能了，更给力的是投行倾向于发现金而非股票，然后话锋一转，不过我们还是先面试吧。当然根据惯例猎头还问我对新工作的期望，工作地点啊什么时候可以开始上班啊，还透露出比较倾向于招人去世界中心美国。事后猎头要了我的简历并说明要向雇主汇报情况，交换意见。</p>

<p>看了我的简历之后，猎头发来了非常详细的职位介绍和笔试的链接。笔试包括一套类似性格测试的题目，一套语言测试和一套在线编程题。心理测试的题目都类似于“如果你发现同事做错了，在多大程度上你会立即向他指出？”。闭着眼睛都能猜出来回答和测试结果的联系。英语题目还是有点挑战的，好多好多单词不认识。编程题目对做过 ACM 的同学们来说很小儿科。五道题分别是：霍夫曼编码，筛法求素数，树的遍历，存储在一维数组中的单链表求环并要求 <code>O(1)</code> 的额外空间，以及最后一道题最长公共子序列。测试时长三小时，我花了一个小时二十分钟做完（大家不要嘲笑我）。语言我选了 Ruby，纯粹是为了炫技。</p>

<p>接下来我就被转交给了投行的 HR，定下了现场面的日期。HR 在面试确认信里告诉我，着装可以是 “what ever you prefer, business casual or suit”。我被吓到了，当天穿了我唯一一身衬衣西服去了出发去了面试地点——当然是挤公交去的，哪里打得起车。投行坐落在市中心最高端的办公楼区域，周围都是赫赫有名的大牌投行。坐电梯到了高层的 Reception，前台很热情又很客套地跟我聊天。可惜我英语不太灵光没能搭上几句话。过了一会儿负责我的 HR 告诉我面试官马上就到。每个人都穿得相当正式，举止得体，言语彬彬有礼。只有我扭扭捏捏地坐着因为身上的西服实在不舒服。二十分钟之后一个穿着 hoodie 短裤拖鞋的大哥出现在我面前，告诉我他就是面试官。</p>

<p>于是我们在一种很奇怪的气氛中开始了面试。题目不难，实现一个模拟 <a href="https://en.wikipedia.org/wiki/Conway's_Game_of_Life" title="Game of Life">Game of Life</a> 的小程序，每秒刷新一次状态。要求和前端的图形界面衔接好，编译出程序，最后还要记得用 Git 把源代码 commit 好。我和面试官花了若干分钟在配置 IDE 上，可惜没有配置成功。我只好选择了没有配置过的 VIM。更作死的是我选了 C++，把绝大部分面试的时间花在了回忆如何申请内存，如何初始化二维 vector，如何传递 vector 给函数，虚函数重载上。过程中我还问 <code>override</code> 关键字应该放在什么地方，彻底暴露了我对 C++11 的不熟悉。我抓耳挠腮的整个过程中面试官没有提供任何帮助，所以我猜他也没什么面试经验（此处一定会被吐槽）。中间一个 shadow interviewer 走了进来， 似乎是个 CTO。我一边疯狂地往我的代码里加调试用的 <code>printf</code>一边听了他的自我介绍，还跟他扯了两句。不知道为什么我还留意到 CTO 同志穿着也很随意，于是更囧了。四十五分钟面试时间到，我的代码已经有一半都是 <code>printf</code> 了，模拟出来的 Game of Life 还是不动的。面试官无奈地要求我把已有代码 commit 上去，还问我对 C++11 知道多少。我只好回答“仅仅试过”了。</p>

<p>面试后我被客客气气地送了出去，然后就冒着小雨回家了。又过了几周我收到猎头邮件，都是“很遗憾”之类的话。我的投行面试就到此为止了。</p>

<p>最后总结经验教训：</p>

<ol>
<li>英语要学好；</li>
<li>不要穿西服面技术岗位；</li>
<li>选最熟悉的编程语言；</li>
<li>面试中遇到困难时要适时寻求帮助。</li>
</ol>


<p>P.S. 这次面试之后我越发觉得偶尔尝试面试其他公司很有意思。后来断断续续又回复了某图书公司、某收据创业公司和某运动腕带公司的招聘邮件。可惜这些尝试都中途夭折掉了，没有走到面试的阶段。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记一个工作中遇到的问题]]></title>
    <link href="http://www.ditsing.com/blog/2014/09/23/ji-yi-ge-gong-zuo-zhong-yu-dao-de-wen-ti/"/>
    <updated>2014-09-23T21:30:47+10:00</updated>
    <id>http://www.ditsing.com/blog/2014/09/23/ji-yi-ge-gong-zuo-zhong-yu-dao-de-wen-ti</id>
    <content type="html"><![CDATA[<p>一年没有写博客了，写一个我今年在工作中遇到的问题吧。</p>

<blockquote><p>首先有一个字符串集合<code>A</code>（母串集），<code>A</code>中大概有1.6x10<sup>10</sup>个字符串。这些字符串大部分都比较短，长度小于100。最长的字符串有2<sup>16</sup>个字符。</p>

<p>还有一个比较小的字符串集合<code>B</code>（子串集）。<code>B</code>里的每个字符串都是<code>A</code>里某个字符串的前缀，共有2.4x10<sup>7</sup>个前缀。<code>B</code>中的每个字符串都与一个非负整数相关联。</p>

<p>现在对于<code>A</code>中的每个字符串<code>a_i</code>，求一个整数。这个整数等于<code>B</code>中所有<code>a_i</code>的前缀所对应的整数的最大值。</p></blockquote>

<p>（之前已经听我白话过这个问题的同学们：是的，问题规模又扩大了。）</p>

<p>背景：<code>A</code>是数据的key集合，<code>B</code>是用户的删除数据请求，删除被匹配的key和它对应的数据。因此，最后<code>A</code>中被匹配到的字符串不会特别多，大约是<code>B</code>的大小的若干倍。可以认为远小于100倍。</p>

<!--more-->


<p>看到这个问题的规模，我们就知道只能跑在一台机器上的算法是不行的。必须设计一个能并行地跑在许多台机器上的算法。</p>

<p>这个问题的规模如果小一点，就相当容易解决。例如，如果<code>B</code>中的字符串少一点，少到2.4x10<sup>4</sup>个。我们就可以把<code>B</code>做成一个Trie直接扔到内存里。准备若干台机器，每台机器都复制一份。给每台机器分配<code>A</code>的一段，各自扫描就好了。这样的复杂度是<code>length(sigma A + sigma B)</code>的。可能会比较占内存，但是现在内存都是白菜价了， who cares。</p>

<p>如果<code>B</code>再大一点点，大到2.4x10<sup>6</sup>，问题也不是那么难。我们可以：</p>

<ol>
<li>把<code>B</code>分成一百份，每次用上述方法处理一份，处理一百次；</li>
<li>或者，找一份可以放在硬盘上的Trie实现（假设能找得到）。Trie的每次查询只用到整个Trie的很小一部分。实现时只需要把查询时能访问到的部分装载到内存里，访问不到的swap到硬盘上就可以了。如果性能不足，还可以把4个byte压缩成一个long，既减少硬盘读写又减少空间浪费。</li>
<li>再或者两种方案结合，把<code>B</code>分成10份，每次用硬盘Trie处理一份。即使用最烂的（我的）实现，Trie文件的大小也不过几十G，可以接受。</li>
</ol>


<p>但是拆分<code>B</code>的方案不能把<code>B</code>拆成太多份。因为每拆一份<code>B</code>都要把<code>A</code>复制一份，也就意味着多一份的数据读写。不幸的是我司的storage层对许多个并行读者的支持并不好，过多读者会导致大家都读得更慢。<code>B</code>如果再大，拆分的方法就不好用了。</p>

<p>大家有什么想法？我的答案在下面，不要偷看哦。</p>

<br/>


<br/>


<br/>


<hr />

<center>答案分割线</center>


<hr />

<br/>


<br/>


<br/>


<br/>


<p>解决方案其实很简单，相信大家也都想到了：hash。</p>

<p>对集合<code>B</code>里的每一个子串，hash它长度为2的整数次幂的<strong>最长前缀</strong>。如果一个串的长度为19，就hash前16个字符；如果长度是32，就hash所有字符。这样我们得到了2.4x10<sup>7</sup>个long，大约占192M内存（我是不是算错了&hellip;.对这个数字没什么信心）。</p>

<p>把这些hash值扔到一个数组<code>b_hash_set</code>里，排序之。</p>

<p>对于集合<code>A</code>里的每个母串，hash它的<strong>每个</strong>长度为2的整数次幂的<strong>前缀</strong>。对于每个字符串<code>a_i</code>，我们会得到<code>log(length(a_i))</code>个数字。称这些hash值的集合为<code>a_hash_set</code>。
如果<code>a_hash_set</code>和<code>b_hash_set</code>中的某一对数字<code>a_hash</code>和<code>b_hash</code>相等，他们分别对应的母串和子串才<strong>有可能</strong>前缀匹配。就不证明了，结论非常明显。</p>

<p>这时再暴力匹配有可能的字符串对，运行时间就完全可以接受了。</p>

<p>一个小优化：在生成<code>a_hash_set</code>的一个值的时候，可以直接在<code>b_hash_set</code>里二分查找这个值。如果不存在，就不用把它放到<code>a_hash_set</code>里了。这样可以显著减小<code>a_hash_set</code>（以及和它关联的数据）的体积。在实践中，优化后<code>a_hash_set</code>的体积缩小了三百倍。</p>

<p>如何找到所有相等的<code>a_hash</code>和<code>b_hash</code>对？把它们扔到一起sort就可以了。<code>a_hash_set</code>的体积可能会特别大，但是我们也有分布式排序算法嘛。</p>

<h3>后话</h3>

<p>上次在群里跟大家讨论的时候，范神@ronaflx提到，他们判断整个字符串相等的时候都会先算hash，然后暴力匹配。我当时还觉得，暴力就暴力吧，hash能有什么作用？仔细一想，使用hash，子串和母串都只需要扫描一遍；而且hash本身的体积比字符串小很多，比较容易传递。在这里顺便感谢范神给我普及字符串匹配基础知识。</p>

<p>但是hash只能判断相等（严格来说，只能确定不等），不能判断前缀。一个常见的workaround是把母串的所有前缀都hash了，再和子串的hash比。这样的方案在母串都不长的情况下很适用。但是在这个问题上，这样做会在时间复杂度上乘一个一百左右的常数。要减小常数，只处理2的整数次幂也是常见workaround：牺牲部分精度（子串的一部分被忽略了），但是可以把常数从100减少到6。</p>

<p>最后，欢迎大家提出更好的方法来打脸！</p>

<h3>吐槽</h3>

<p>Java的TreeSet存2.4x10<sup>7</sup>个数，居然要占用10多G内存！你丫是暴力数组实现的Trie吧！</p>

<p>下次给自己的service设计功能的时候，一定要先想想到底能不能高效实现。堂堂大Google，若干M个请求都处理不好，混不混了！</p>

<h3>感慨</h3>

<p>本文就是我今年工作最大的成绩了。进入Google一年，蹉跎一年，一事无成，Todo List 基本没有刷，能力进步为零。</p>

<p>逆水行舟，不进则退。与君共勉！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Compiler学后]]></title>
    <link href="http://www.ditsing.com/blog/2013/11/17/compilerxue-hou/"/>
    <updated>2013-11-17T22:40:00+11:00</updated>
    <id>http://www.ditsing.com/blog/2013/11/17/compilerxue-hou</id>
    <content type="html"><![CDATA[<p>从我高三听说“公开课”开始，我就觉得这个东西一定会有前途。那时候他们还叫Open Course Wave，公开课的形式还都是课程笔记和清晰度超低的课堂视频。当时我看完了流行的《哲学：死亡》和《聆听音乐》，哈佛的《公正》和《幸福》都只看了一点点。另外还囤下了
好几套课程，一直拖到现在都没有接着看。可惜当时没有抓紧时间上《Algorithm》和C语言的课程，要不然上大学的时候也不会那么智商捉急了。</p>

<p>课程名两边用什么标点符号都觉得不对劲，我就用书名号了。</p>

<p>回到正题。大三上编译原理的时候我一直都在忙其他事情——ACM，GRE，莫名其妙的项目，实习，以及无聊的单机版Dota。跟随机房里诸位大牛的脚步，我开始了《Compiler》课程的学习。当时觉得自己自制力不行，没敢跟着老师的脚步上，而是选择了自助模式。看视频做作业，学习过程断断续续，前后持续了近一年。</p>

<p>课程设置非常不错，课堂上讲解的内容也比较简单，基本被我们大HIT课程覆盖。虽然我大HIT讲的我基本没听懂——也有可能是我总在上课的时候睡觉。视频讲得比较浅，但是很详细，有许多step-by-step的例子，例如模拟自动机和算法的运行等等。我之前一直对我们教材龙书的难度深表不满：许多涉及实现细节的代码和算法，跟原理混在一起，真的很难懂很难懂。我也不知道该怎么讲才能讲简单讲清楚。但是我想Alex Aiken教授的这门《Compiler》真的做到了易懂：整个编译器地框架和结构讲得非常清晰，具体算法和原理也都有介绍。教授涉猎很多，跟着教授上课不会担心他漏掉什么东西没有讲。编译器的实现主要体现在作业里，需要自己下一番功夫才能做好。小课堂大作业，我最喜欢的模式。所以我这篇博客会一直说作业怎么样怎么样怎么样。</p>

<!--more-->


<p>下面就来了。</p>

<p>整个课程的作业加在一起就是设计一个编译器。它首先提供了一个完整版的编译器作为标准。这个编译器的框架搭得好，比较容易扩展；模块化也做得非常好，编译的每个步骤对应一个模块，模块之间接口简单明确，依赖很轻。这样一来一个模块可以单独拆出来交给学生实现，其他模块都用标准版的，易于调试和查错。框架屏蔽了许多细节，在前两个作业中基本不需要关心底层实现。唯一的缺点是框架提供的utility不太好用，需要自己实现正序的单链表。在编译的时候保持方法和成员的顺序是一个非常好的特性，所以我们需要不改变顺序的单链表。</p>

<p>作业中编译器的源语言是Cool语言。Cool是一种完美的教学语言。没有指针没有数组，一切都是对象，有继承和多态，多了很多十分有意思的细节；自创了type-case语句，非常有用而且实现非常有趣的语句。编译器的目标语言是MIPS汇编，比X86概念更少更容易入门。</p>

<h2>四次作业的感受</h2>

<p>可以毫不夸张地说，作业是这门课程里最实用最有价值的部分。我的绝大部分时间都花在了作业上，而且我觉得这个时间花得十分值得。</p>

<p>PA2词法分析。总体来说比较简单。部分原因是，与后来的三个作业相比，这个作业要解决的问题本身比较简单。作业使用的工具flex对这个问题做了非常好的抽象，我们只需要用正则表达式描述识别token的规则就行了。当然，并不是所有编程语言的语法规则都可以用正则语言来描述（貌似大部分都不能用正则语言完整描述）。比如Cool语言允许嵌套注释，在处理的过程中就必须记录一下当前注释嵌套的层数，才能正确配对注释开始和结束。这个作业的用意不在于考量大家使用正则表达式的能力，所以Cool的语法有很多明显的简化，避开了大部分难点。时间太久了难点都记不得了，在这里就不列出了。做这个作业的时候可以试图简单扩展一下作业里规定的Cool的语法，相当有意思。</p>

<p>PA3语法分析。相对于PA2的简单直白，PA3就相当抽象了。PA3用到的工具是Bison，比flex复杂了很多。阅读Bison的说明书花了我三四天的时间（根据G+ Post的记录）。加上课程提供的各种基础库（AST等等）是从这次作业开始引入的，使得这次作业的阅读量和理解量非常大。作业本身的难度一般，完成一个上下文无关文法，规定操作符的结合性等等。我当时的时间主要花费在处理／抽象各种空和非空的列表上了。其实只要文档读得细，应该很顺利就能做完并且拿到满分——我的意思是在打分器的帮助下。我试图阅读Bison编译出来的C语言程序，失败了；有时间要了解下Bison的算法。</p>

<p>这里必须表扬一下Compiler课程各个作业中的打分脚本。本质上就是集合了无数test case的一个库，颇有Online Judge风格。要把这个库里的每一个case都处理好是非常不容易的。在这四个作业中，我第一次提交的版本基本都在十分以下——满分是50-80。但是经过无数次的修改和刷分，最后拿到满分也不是特别困难。
我觉得这种做法是对批作业模式的一种改进。尤其是在作业十分复杂的情况下，助教基本不可能理解每个学生的代码，注意到作业里的每个细节，也就没办法高效地评分。这个脚本对学生也特别有用。它大大缩短了学生得到作业反馈的时间，对自学帮助很大。这个方法和助教答疑结合使用，应该会有非常好的效果。当然这一切都建立在一个前提上：评分脚本一定要做得非常用心，包含足够多的case使得它不容易被针对。</p>

<p>PA4语义分析。这是整个作业里最难的部分。我花了整整十四天，每天从早到晚都在研究这个问题。很庆幸毕设选了个有把握的题目，这样才有时间专心做这些。PA4整体设计很重要。我是先实现了一个类的继承关系树，每个class都是这棵树的一个结点。建树的时候顺便完成了继承关系的检查，确保每个类都有父亲。树中允许某些类没有定义，将报错推迟到类型检查的部分，这样更加user-friendly。然后再遍历一遍收集结点深度和方法的信息。接着检查每个方法，成员和表达式。我第一次实现的类型检查非常严格，对错误几乎是零容忍。后来为了容错，推断了很多表达式的类型（例如加减法，一定是整数），检查到错误只报错而不退出，继续类型检查。因为我听说“遇到第一个错误就退出的编译器不是好编译器”。（因为不这么干拿不了满分。）</p>

<p>在检查类型的时候我遇到了SELF_TYPE和找到两个树结点的最近公共祖先两个问题。因为代码里已经有了很多trick和workaround，所以我不得不在class树结点外又包了一层Type类，专门用于处理这两个问题；又定义了Type和树结点的隐式转换，让以前的代码能继续使用。这样改来该去改得自己都晕了，最后终于过了所有的case。</p>

<p>在这个作业里，表（Table）是个非常重要的基础设施。从类名查询Type，查询方法和成员在不在某个类中，收集某个类的所有方法，都要用到表。我比较倾向于变量和类名要单独建表，实现会比较方便。但是整个框架应该是倾向于把所有标示符(identifier)都放在一个表里的。作业的框架提供了ScopeTable来解决这个问题。</p>

<p>还有一个问题是如何存储类的方法和成员的表。子类会继承父类的所有方法和成员，我们要不要在子类的方法表里再存储一遍父类的方法／成员呢？很直白的空间－时间的取舍。框架提供的ScopeTable非常好地解决了这个问题。ScopeTable被设计成一个可以包含另外一个ScopeTable作子表的表。对外层Table的修改不会影响内层的Table。虽然ScopeTable其实是用链表实现的，但是我相信肯定会有更高效的数据结构来解决这个问题。</p>

<p>PA5代码生成。在视频里介绍了有一个寄存器和一个栈来做计算的机器（<del>忘了名字叫什么了</del>不就是下推自动机么！）。这种机器比较容易用汇编语言实现，而且我们都知道功能跟图灵机是一样的。这次作业涉及到了许多新问题，例如寄存器分配和临时变量的分配。不会高级算法的（比如我）只好用直白的低效的算法来实现了。我在这个作业中使用了做HIT的编译原理课程设计的思路，即约定每个表达式都把返回值放在a0（或者某个其他寄存器）里，其他寄存器都当做临时变量来用，尽量不使用栈。当时我的课程设计确实没有做出来，因为我当时使用了一种非常复杂的方法实现了用栈保存结果，而且也没有把这种做法推广到所有计算上。</p>

<h2>遗憾和吐槽</h2>

<p>课程学完了还是有些许遗憾的。PA2里不清楚生成自动机的细节。PA3里没有实现报错的时候附加行号，而且一直也没有弄明白行号到底是怎么工作的。PA4设计有点冗余，多加了一个类；细节处理十分混乱；最近公共祖先用的是记下结点深度然后向上遍历的方法实现的。PA5没有实现GC，代码生成中有许多hack；依赖于栈，没有分配寄存器算法。以后有时间要完善一下，做一份标准答案出来。</p>

<p>对作业的不满也有一些。在抽象语法树（AST）中，attr和method基于一个共同的基类，给类型检查和代码生成造成了很多麻烦。我必须实现一个虚函数来判断一个结点是方法还是成员。但是我也没有想出更好的方法来实现AST，所以这只是个吐槽。
ScopeTable很强大但是也很弱。整个表只能查但是不能遍历，这让我非常不爽。因为代码生成很显然需要遍历所有的方法和成员，所以我必须在存储ScopeTable的同时自己实现一个链表存储所有的成员。同样的冗余发生在PA4和PA5中间，PA4中收集过的许多信息PA5要再收集一遍，代码重复而且效率低。</p>

<p>最后，作业框架不支持添加自己的源文件，导致我的单个源文件超过了2000行，各种代码堆在一起很难阅读。</p>

<p>要不要把这些吐槽总结一下，发给教授作为Feedback？</p>

<h2>总结</h2>

<p>作业虽然做完了但是很多概念都忘掉了。如果有时间，我还会努力完成完成剩下的Quiz和Assignment。</p>

<p>这门课程的一个“副作用”是改变了我对Java的看法。曾经我觉得Java是一门又慢又慢又慢的语言。但是从编译器的角度来看，Java还是很优秀的。它实现了好多C/CPP没有实现的高级特性，例如Reflection和运行时加载类。这<del>给了我继续用Java干活的勇气</del>让我在使用Java的时候感觉好了不少。另外我还听说经过仔细<del>调教</del>调校的Java虚拟机可以让Java代码的效率达到CPP的98%左右。我着实被震惊了。以后再也不黑Java了。</p>

<p>《Compiler》也给我了一个（自我感觉）非常好的入门指引，如果要进一步在这个领域里学习，我会重点关注以下几个方面：寄存器分配，临时变量分配，生成自动机语法，语法分析的算法，代码优化算法以及其他高级语言语法的实现。</p>

<p>写到这里，我再一次深深地感觉到了人和人的不同。我想要继续学习就只好自己去查书，寻求帮助和指导对我来说异常困难。大学里的研究生们同学呢？本以为公开课会给我们这些没考上大学的人一个逆袭的机会，现在才意识到，要逆袭，这才仅仅是一个开始。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[博客重新开张啦]]></title>
    <link href="http://www.ditsing.com/blog/2013/10/22/bo-ke-zhong-xin-kai-zhang-la/"/>
    <updated>2013-10-22T23:31:00+11:00</updated>
    <id>http://www.ditsing.com/blog/2013/10/22/bo-ke-zhong-xin-kai-zhang-la</id>
    <content type="html"><![CDATA[<p>从FB回来之后再没写过博客。原因很多，一个是因为忙，另外一个是因为&hellip;心灰意冷专心学术思考人生去了。</p>

<p>那我为什么突然抽风要回来写日志了呢？</p>

<ul>
<li>第一，当然是因为在悉尼的生活稳定下来了。</li>
<li>第二，经过努力终于修复了博客的评论数量，现在主页上的评论统计是正确的了。</li>
<li>第三纯粹是个意外，我突然发现一年前的今天我搞了一个<a href="/todo-list/" title="Todo List">Todo list</a>。这个list上除了第一条之外我居然都完成了。这点让我非常开心。</li>
</ul>


<p>综上所述，心情好了就会来写博客了。</p>

<p>我还是有一个写作计划的。
<a href="https://class.coursera.org/compilers-selfservice/class" title="Compilers">Coursera上的Compiler</a>课程基本上学完了，要写心得体会；XFSd做完了也有很多话想说。把计划公布了就更有压力，希望我不会拖得太久。</p>

<p>好吧，按照惯例，我来回忆一下一年的生活。各位看官可以不用继续往下读了。请期待我另外的两篇文章吧。</p>

<!-- more -->


<hr />

<center>我最喜欢流水账了的分割线</center>


<hr />

<br/>


<p>这一年发生了很多事情，但是大部分都在计划之中。</p>

<p>十一月份滚回家，在家里一直看美剧，休息了两个月。（其实是我不记得除了看美剧我到底干什么了，又没有写日记，各大网站上都找不到自己的活动记录。）修改：我在家呆了几天就直接回学校了。在学校花了四个星期时间修满了学分，途中还写了这辈子第一个RPC——middleware，用的还是从来没用过的Ruby。在学校还接了现在的Offer，给自己电脑加了内存，修改了简历投了湾区各大公司（并在接下来的几个月里被搓）。找@icek内推了豆瓣并拿到Offer（然后发现时间错不开拒掉了）。</p>

<p>这样就到了元旦。我在元旦这一天坐上了回家的火车，开始了漫长的寒假。寒假基本贡献给了Cousera上的Compiler作业（和搜狐上的美剧）。这点可以从<a href="https://github.com/ditsing/compiler" title="Compiler">Github</a>上的<a href="https://github.com/ditsing/compiler/commits/master" title="Commits">commit</a>纪录看出来。当然我也参加了好多场TopCoder，其中大部分以暴跌收场。看我的人生这么艰难大家就不要拆穿我了。</p>

<p>开学了之后我的主要活动就是Compiler和毕设了。在开始做毕设之后的很长一段时间里（长达一个月），我的主要活动还是集中在Compiler的作业上。主要原因是配置Windows驱动开发环境实在是太蛋疼了，我装了两台Win7一台Win8外加一个虚拟机才搞定。直到四月份毕业设计的中期检查dealine之前的一周，数量巨大的commits被提交到了我在Github的项目上。中期检查的时候disk image parser已经可以用了。</p>

<p>中期检查之后我的工作的重心移到了XFSd的Windows接口上。开发XFSd的流程可以用Compiling Error(CE)&ndash;>删代码->CE->删代码->CE－>加代码->CE->删代码->CE&hellip;&hellip;&hellip;.&ndash;>WA->WA->WA来概括。经过5月初的一阵疯狂开发，项目在功能上基本成型了，但是有一个很大的Bug没有解决——磁盘镜像里的文件不能用命令行复制，但是自己写程序可以读出来。我花了很大精力来找这个bug的原因，但是直到毕设答辩也没找到。不过最后我还是fix了这个bug，但已经忘了是怎么fix的了。有些当时非常在意的事情，过了一段时间之后会发现也不过如此。</p>

<p>五月份六月份初这一段时间，我又回过头去写了Compiler的第三个作业。作业有判分脚本，用各种case测试程序。刷分的感觉跟刷题差不多，过程非常开心。而且这一段我一直在家，狠狠地享受了一把生活。</p>

<p>六月末七月初呢，毕设和论文时间。印象中我没有花多久在学习上面。很怀念我们班同学连续一周的疯狂聚餐。</p>

<p>之后是另外两个半月安逸的生活。安逸之中突然得知办签证要考雅思，匆匆准备了之后就在八月中旬参加了考试，成绩还算可以接受。接下来又经历了很多很多办签证流程。不过我的签证格外给力，所有材料提交之后四天就被批准了。拿到了签证之后我终于想到要做点实事了，于是把Compiler的最后一个作业刷到了满分，并且看完了所有的教学视频。现在计划把小作业和Quiz都刷完之后写总结。</p>

<p>最后就是刚刚过完的十月了。周末再来一篇文章写写搬家到悉尼的见闻。挖了好多坑啊。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[接近尾声：Facebook又三周]]></title>
    <link href="http://www.ditsing.com/blog/2012/11/11/jie-jin-wei-sheng-%3Afacebookyou-san-zhou/"/>
    <updated>2012-11-11T21:57:00+11:00</updated>
    <id>http://www.ditsing.com/blog/2012/11/11/jie-jin-wei-sheng-:facebookyou-san-zhou</id>
    <content type="html"><![CDATA[<p>第九，第十，第十一周。今晚是我本周唯一一个过了九点还不困的晚上。</p>

<ol>
<li>第九周本来是应该开始新工作的，结果却一直在对旧工作修修补补。新工作进展不错，雏形已经出来了。</li>
<li>第十周没有什么实质性的进展，尝试做了一个工具。实验发现工具的效果不太稳定，跟预想有很大误差。Mentor认为我没办法处理这个问题，于是让我先放下了。真正扫尾的时间到了。</li>
<li>第十一周扫尾，完成我一直在挂念的任务——重构那个巨丑无比的旧代码。为了搞清楚它的逻辑我真是脑袋都大了。让我重新开发估计也就一天就能搞定。事实上我确实重新开发了几乎所有重要的部分。800余行代码里连续没有改动的行数最大值小于13。</li>
</ol>


<p>这次没有心情再写流水账了。之前写是因为觉得这段时间很重要，发生的每件事情都要记下来。现在觉得不一样了，没有什么事情很重要。认真去生活，认真去思考，认真去品味。这就够了，犯不着大动干戈。
临近离开反而心如止水，没有思前想后的犹豫，没有患得患失的顾虑。在Facebook可以为未来奋斗，回到哈尔滨的也可以。</p>

<p>只可惜&hellip;</p>

<p>必须说，这将是一段珍贵的记忆。</p>
]]></content>
  </entry>
  
</feed>
