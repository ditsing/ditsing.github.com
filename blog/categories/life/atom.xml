<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Life | Blog of Ditsing]]></title>
  <link href="http://ditsing.com/blog/categories/life/atom.xml" rel="self"/>
  <link href="http://ditsing.com/"/>
  <updated>2014-09-23T22:35:14+10:00</updated>
  <id>http://ditsing.com/</id>
  <author>
    <name><![CDATA[ditsing]]></name>
    <email><![CDATA[ditsing@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[记一个工作中遇到的问题]]></title>
    <link href="http://ditsing.com/blog/2014/09/23/ji-yi-ge-gong-zuo-zhong-yu-dao-de-wen-ti/"/>
    <updated>2014-09-23T21:30:47+10:00</updated>
    <id>http://ditsing.com/blog/2014/09/23/ji-yi-ge-gong-zuo-zhong-yu-dao-de-wen-ti</id>
    <content type="html"><![CDATA[<p>一年没有写博客了，写一个我今年在工作中遇到的问题吧。</p>

<blockquote><p>首先有一个字符串集合<code>A</code>（母串集），<code>A</code>中大概有1.6x10<sup>10</sup>个字符串。这些字符串大部分都比较短，长度小于100。最长的字符串有2<sup>16</sup>个字符。</p>

<p>还有一个比较小的字符串集合<code>B</code>（子串集）。<code>B</code>里的每个字符串都是<code>A</code>里某个字符串的前缀，共有2.4x10<sup>7</sup>个前缀。<code>B</code>中的每个字符串都与一个非负整数相关联。</p>

<p>现在对于<code>A</code>中的每个字符串<code>a_i</code>，求一个整数。这个整数等于<code>B</code>中所有<code>a_i</code>的前缀所对应的整数的最大值。</p></blockquote>

<p>（之前已经听我白话过这个问题的同学们：是的，问题规模又扩大了。）</p>

<p>背景：<code>A</code>是数据的key集合，<code>B</code>是用户的删除数据请求，删除被匹配的key和它对应的数据。因此，最后<code>A</code>中被匹配到的字符串不会特别多，大约是<code>B</code>的大小的若干倍。可以认为远小于100倍。</p>

<!--more-->


<p>看到这个问题的规模，我们就知道只能跑在一台机器上的算法是不行的。必须设计一个能并行地跑在许多台机器上的算法。</p>

<p>这个问题的规模如果小一点，就相当容易解决。例如，如果<code>B</code>中的字符串少一点，少到2.4x10<sup>4</sup>个。我们就可以把<code>B</code>做成一个Trie直接扔到内存里。准备若干台机器，每台机器都复制一份。给每台机器分配<code>A</code>的一段，各自扫描就好了。这样的复杂度是<code>length(sigma A + sigma B)</code>的。可能会比较占内存，但是现在内存都是白菜价了， who cares。</p>

<p>如果<code>B</code>再大一点点，大到2.4x10<sup>6</sup>，问题也不是那么难。我们可以：</p>

<ol>
<li>把<code>B</code>分成一百份，每次用上述方法处理一份，处理一百次；</li>
<li>或者，找一份可以放在硬盘上的Trie实现（假设能找得到）。Trie的每次查询只用到整个Trie的很小一部分。实现时只需要把查询时能访问到的部分装载到内存里，访问不到的swap到硬盘上就可以了。如果性能不足，还可以把4个byte压缩成一个long，既减少硬盘读写又减少空间浪费。</li>
<li>再或者两种方案结合，把<code>B</code>分成10份，每次用硬盘Trie处理一份。即使用最烂的（我的）实现，Trie文件的大小也不过几十G，可以接受。</li>
</ol>


<p>但是拆分<code>B</code>的方案不能把<code>B</code>拆成太多份。因为每拆一份<code>B</code>都要把<code>A</code>复制一份，也就意味着多一份的数据读写。不幸的是我司的storage层对许多个并行读者的支持并不好，过多读者会导致大家都读得更慢。<code>B</code>如果再大，拆分的方法就不好用了。</p>

<p>大家有什么想法？我的答案在下面，不要偷看哦。</p>

<br/>


<br/>


<br/>


<hr />

<center>答案分割线</center>


<hr />

<br/>


<br/>


<br/>


<br/>


<p>解决方案其实很简单，相信大家也都想到了：hash。</p>

<p>对集合<code>B</code>里的每一个子串，hash它长度为2的整数次幂的<strong>最长前缀</strong>。如果一个串的长度为19，就hash前16个字符；如果长度是32，就hash所有字符。这样我们得到了2.4x10<sup>7</sup>个long，大约占192M内存（我是不是算错了&hellip;.对这个数字没什么信心）。</p>

<p>把这些hash值扔到一个数组<code>b_hash_set</code>里，排序之。</p>

<p>对于集合<code>A</code>里的每个母串，hash它的<strong>每个</strong>长度为2的整数次幂的<strong>前缀</strong>。对于每个字符串<code>a_i</code>，我们会得到<code>log(length(a_i))</code>个数字。称这些hash值的集合为<code>a_hash_set</code>。
如果<code>a_hash_set</code>和<code>b_hash_set</code>中的某一对数字<code>a_hash</code>和<code>b_hash</code>相等，他们分别对应的母串和子串才<strong>有可能</strong>前缀匹配。就不证明了，结论非常明显。</p>

<p>这时再暴力匹配有可能的字符串对，运行时间就完全可以接受了。</p>

<p>一个小优化：在生成<code>a_hash_set</code>的一个值的时候，可以直接在<code>b_hash_set</code>里二分查找这个值。如果不存在，就不用把它放到<code>a_hash_set</code>里了。这样可以显著减小<code>a_hash_set</code>（以及和它关联的数据）的体积。在实践中，优化后<code>a_hash_set</code>的体积缩小了三百倍。</p>

<p>如何找到所有相等的<code>a_hash</code>和<code>b_hash</code>对？把它们扔到一起sort就可以了。<code>a_hash_set</code>的体积可能会特别大，但是我们也有分布式排序算法嘛。</p>

<h3>后话</h3>

<p>上次在群里跟大家讨论的时候，范神@ronaflx提到，他们判断整个字符串相等的时候都会先算hash，然后暴力匹配。我当时还觉得，暴力就暴力吧，hash能有什么作用？仔细一想，使用hash，子串和母串都只需要扫描一遍；而且hash本身的体积比字符串小很多，比较容易传递。在这里顺便感谢范神给我普及字符串匹配基础知识。</p>

<p>但是hash只能判断相等（严格来说，只能确定不等），不能判断前缀。一个常见的workaround是把母串的所有前缀都hash了，再和子串的hash比。这样的方案在母串都不长的情况下很适用。但是在这个问题上，这样做会在时间复杂度上乘一个一百左右的常数。要减小常数，只处理2的整数次幂也是常见workaround：牺牲部分精度（子串的一部分被忽略了），但是可以把常数从100减少到6。</p>

<p>最后，欢迎大家提出更好的方法来打脸！</p>

<h3>吐槽</h3>

<p>Java的TreeSet存2.4x10<sup>7</sup>个数，居然要占用10多G内存！你丫是暴力数组实现的Trie吧！</p>

<p>下次给自己的service设计功能的时候，一定要先想想到底能不能高效实现。堂堂大Google，若干M个请求都处理不好，混不混了！</p>

<h3>感慨</h3>

<p>本文就是我今年工作最大的成绩了。进入Google一年，蹉跎一年，一事无成，Todo List 基本没有刷，能力进步为零。</p>

<p>逆水行舟，不进则退。与君共勉！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Compiler学后]]></title>
    <link href="http://ditsing.com/blog/2013/11/17/compilerxue-hou/"/>
    <updated>2013-11-17T22:40:00+11:00</updated>
    <id>http://ditsing.com/blog/2013/11/17/compilerxue-hou</id>
    <content type="html"><![CDATA[<p>从我高三听说“公开课”开始，我就觉得这个东西一定会有前途。那时候他们还叫Open Course Wave，公开课的形式还都是课程笔记和清晰度超低的课堂视频。当时我看完了流行的《哲学：死亡》和《聆听音乐》，哈佛的《公正》和《幸福》都只看了一点点。另外还囤下了
好几套课程，一直拖到现在都没有接着看。可惜当时没有抓紧时间上《Algorithm》和C语言的课程，要不然上大学的时候也不会那么智商捉急了。</p>

<p>课程名两边用什么标点符号都觉得不对劲，我就用书名号了。</p>

<p>回到正题。大三上编译原理的时候我一直都在忙其他事情——ACM，GRE，莫名其妙的项目，实习，以及无聊的单机版Dota。跟随机房里诸位大牛的脚步，我开始了《Compiler》课程的学习。当时觉得自己自制力不行，没敢跟着老师的脚步上，而是选择了自助模式。看视频做作业，学习过程断断续续，前后持续了近一年。</p>

<p>课程设置非常不错，课堂上讲解的内容也比较简单，基本被我们大HIT课程覆盖。虽然我大HIT讲的我基本没听懂——也有可能是我总在上课的时候睡觉。视频讲得比较浅，但是很详细，有许多step-by-step的例子，例如模拟自动机和算法的运行等等。我之前一直对我们教材龙书的难度深表不满：许多涉及实现细节的代码和算法，跟原理混在一起，真的很难懂很难懂。我也不知道该怎么讲才能讲简单讲清楚。但是我想Alex Aiken教授的这门《Compiler》真的做到了易懂：整个编译器地框架和结构讲得非常清晰，具体算法和原理也都有介绍。教授涉猎很多，跟着教授上课不会担心他漏掉什么东西没有讲。编译器的实现主要体现在作业里，需要自己下一番功夫才能做好。小课堂大作业，我最喜欢的模式。所以我这篇博客会一直说作业怎么样怎么样怎么样。</p>

<!--more-->


<p>下面就来了。</p>

<p>整个课程的作业加在一起就是设计一个编译器。它首先提供了一个完整版的编译器作为标准。这个编译器的框架搭得好，比较容易扩展；模块化也做得非常好，编译的每个步骤对应一个模块，模块之间接口简单明确，依赖很轻。这样一来一个模块可以单独拆出来交给学生实现，其他模块都用标准版的，易于调试和查错。框架屏蔽了许多细节，在前两个作业中基本不需要关心底层实现。唯一的缺点是框架提供的utility不太好用，需要自己实现正序的单链表。在编译的时候保持方法和成员的顺序是一个非常好的特性，所以我们需要不改变顺序的单链表。</p>

<p>作业中编译器的源语言是Cool语言。Cool是一种完美的教学语言。没有指针没有数组，一切都是对象，有继承和多态，多了很多十分有意思的细节；自创了type-case语句，非常有用而且实现非常有趣的语句。编译器的目标语言是MIPS汇编，比X86概念更少更容易入门。</p>

<h2>四次作业的感受</h2>

<p>可以毫不夸张地说，作业是这门课程里最实用最有价值的部分。我的绝大部分时间都花在了作业上，而且我觉得这个时间花得十分值得。</p>

<p>PA2词法分析。总体来说比较简单。部分原因是，与后来的三个作业相比，这个作业要解决的问题本身比较简单。作业使用的工具flex对这个问题做了非常好的抽象，我们只需要用正则表达式描述识别token的规则就行了。当然，并不是所有编程语言的语法规则都可以用正则语言来描述（貌似大部分都不能用正则语言完整描述）。比如Cool语言允许嵌套注释，在处理的过程中就必须记录一下当前注释嵌套的层数，才能正确配对注释开始和结束。这个作业的用意不在于考量大家使用正则表达式的能力，所以Cool的语法有很多明显的简化，避开了大部分难点。时间太久了难点都记不得了，在这里就不列出了。做这个作业的时候可以试图简单扩展一下作业里规定的Cool的语法，相当有意思。</p>

<p>PA3语法分析。相对于PA2的简单直白，PA3就相当抽象了。PA3用到的工具是Bison，比flex复杂了很多。阅读Bison的说明书花了我三四天的时间（根据G+ Post的记录）。加上课程提供的各种基础库（AST等等）是从这次作业开始引入的，使得这次作业的阅读量和理解量非常大。作业本身的难度一般，完成一个上下文无关文法，规定操作符的结合性等等。我当时的时间主要花费在处理／抽象各种空和非空的列表上了。其实只要文档读得细，应该很顺利就能做完并且拿到满分——我的意思是在打分器的帮助下。我试图阅读Bison编译出来的C语言程序，失败了；有时间要了解下Bison的算法。</p>

<p>这里必须表扬一下Compiler课程各个作业中的打分脚本。本质上就是集合了无数test case的一个库，颇有Online Judge风格。要把这个库里的每一个case都处理好是非常不容易的。在这四个作业中，我第一次提交的版本基本都在十分以下——满分是50-80。但是经过无数次的修改和刷分，最后拿到满分也不是特别困难。
我觉得这种做法是对批作业模式的一种改进。尤其是在作业十分复杂的情况下，助教基本不可能理解每个学生的代码，注意到作业里的每个细节，也就没办法高效地评分。这个脚本对学生也特别有用。它大大缩短了学生得到作业反馈的时间，对自学帮助很大。这个方法和助教答疑结合使用，应该会有非常好的效果。当然这一切都建立在一个前提上：评分脚本一定要做得非常用心，包含足够多的case使得它不容易被针对。</p>

<p>PA4语义分析。这是整个作业里最难的部分。我花了整整十四天，每天从早到晚都在研究这个问题。很庆幸毕设选了个有把握的题目，这样才有时间专心做这些。PA4整体设计很重要。我是先实现了一个类的继承关系树，每个class都是这棵树的一个结点。建树的时候顺便完成了继承关系的检查，确保每个类都有父亲。树中允许某些类没有定义，将报错推迟到类型检查的部分，这样更加user-friendly。然后再遍历一遍收集结点深度和方法的信息。接着检查每个方法，成员和表达式。我第一次实现的类型检查非常严格，对错误几乎是零容忍。后来为了容错，推断了很多表达式的类型（例如加减法，一定是整数），检查到错误只报错而不退出，继续类型检查。因为我听说“遇到第一个错误就退出的编译器不是好编译器”。（因为不这么干拿不了满分。）</p>

<p>在检查类型的时候我遇到了SELF_TYPE和找到两个树结点的最近公共祖先两个问题。因为代码里已经有了很多trick和workaround，所以我不得不在class树结点外又包了一层Type类，专门用于处理这两个问题；又定义了Type和树结点的隐式转换，让以前的代码能继续使用。这样改来该去改得自己都晕了，最后终于过了所有的case。</p>

<p>在这个作业里，表（Table）是个非常重要的基础设施。从类名查询Type，查询方法和成员在不在某个类中，收集某个类的所有方法，都要用到表。我比较倾向于变量和类名要单独建表，实现会比较方便。但是整个框架应该是倾向于把所有标示符(identifier)都放在一个表里的。作业的框架提供了ScopeTable来解决这个问题。</p>

<p>还有一个问题是如何存储类的方法和成员的表。子类会继承父类的所有方法和成员，我们要不要在子类的方法表里再存储一遍父类的方法／成员呢？很直白的空间－时间的取舍。框架提供的ScopeTable非常好地解决了这个问题。ScopeTable被设计成一个可以包含另外一个ScopeTable作子表的表。对外层Table的修改不会影响内层的Table。虽然ScopeTable其实是用链表实现的，但是我相信肯定会有更高效的数据结构来解决这个问题。</p>

<p>PA5代码生成。在视频里介绍了有一个寄存器和一个栈来做计算的机器（<del>忘了名字叫什么了</del>不就是下推自动机么！）。这种机器比较容易用汇编语言实现，而且我们都知道功能跟图灵机是一样的。这次作业涉及到了许多新问题，例如寄存器分配和临时变量的分配。不会高级算法的（比如我）只好用直白的低效的算法来实现了。我在这个作业中使用了做HIT的编译原理课程设计的思路，即约定每个表达式都把返回值放在a0（或者某个其他寄存器）里，其他寄存器都当做临时变量来用，尽量不使用栈。当时我的课程设计确实没有做出来，因为我当时使用了一种非常复杂的方法实现了用栈保存结果，而且也没有把这种做法推广到所有计算上。</p>

<h2>遗憾和吐槽</h2>

<p>课程学完了还是有些许遗憾的。PA2里不清楚生成自动机的细节。PA3里没有实现报错的时候附加行号，而且一直也没有弄明白行号到底是怎么工作的。PA4设计有点冗余，多加了一个类；细节处理十分混乱；最近公共祖先用的是记下结点深度然后向上遍历的方法实现的。PA5没有实现GC，代码生成中有许多hack；依赖于栈，没有分配寄存器算法。以后有时间要完善一下，做一份标准答案出来。</p>

<p>对作业的不满也有一些。在抽象语法树（AST）中，attr和method基于一个共同的基类，给类型检查和代码生成造成了很多麻烦。我必须实现一个虚函数来判断一个结点是方法还是成员。但是我也没有想出更好的方法来实现AST，所以这只是个吐槽。
ScopeTable很强大但是也很弱。整个表只能查但是不能遍历，这让我非常不爽。因为代码生成很显然需要遍历所有的方法和成员，所以我必须在存储ScopeTable的同时自己实现一个链表存储所有的成员。同样的冗余发生在PA4和PA5中间，PA4中收集过的许多信息PA5要再收集一遍，代码重复而且效率低。</p>

<p>最后，作业框架不支持添加自己的源文件，导致我的单个源文件超过了2000行，各种代码堆在一起很难阅读。</p>

<p>要不要把这些吐槽总结一下，发给教授作为Feedback？</p>

<h2>总结</h2>

<p>作业虽然做完了但是很多概念都忘掉了。如果有时间，我还会努力完成完成剩下的Quiz和Assignment。</p>

<p>这门课程的一个“副作用”是改变了我对Java的看法。曾经我觉得Java是一门又慢又慢又慢的语言。但是从编译器的角度来看，Java还是很优秀的。它实现了好多C/CPP没有实现的高级特性，例如Reflection和运行时加载类。这<del>给了我继续用Java干活的勇气</del>让我在使用Java的时候感觉好了不少。另外我还听说经过仔细<del>调教</del>调校的Java虚拟机可以让Java代码的效率达到CPP的98%左右。我着实被震惊了。以后再也不黑Java了。</p>

<p>《Compiler》也给我了一个（自我感觉）非常好的入门指引，如果要进一步在这个领域里学习，我会重点关注以下几个方面：寄存器分配，临时变量分配，生成自动机语法，语法分析的算法，代码优化算法以及其他高级语言语法的实现。</p>

<p>写到这里，我再一次深深地感觉到了人和人的不同。我想要继续学习就只好自己去查书，寻求帮助和指导对我来说异常困难。大学里的研究生们同学呢？本以为公开课会给我们这些没考上大学的人一个逆袭的机会，现在才意识到，要逆袭，这才仅仅是一个开始。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[博客重新开张啦]]></title>
    <link href="http://ditsing.com/blog/2013/10/22/bo-ke-zhong-xin-kai-zhang-la/"/>
    <updated>2013-10-22T23:31:00+11:00</updated>
    <id>http://ditsing.com/blog/2013/10/22/bo-ke-zhong-xin-kai-zhang-la</id>
    <content type="html"><![CDATA[<p>从FB回来之后再没写过博客。原因很多，一个是因为忙，另外一个是因为&hellip;心灰意冷专心学术思考人生去了。</p>

<p>那我为什么突然抽风要回来写日志了呢？</p>

<ul>
<li>第一，当然是因为在悉尼的生活稳定下来了。</li>
<li>第二，经过努力终于修复了博客的评论数量，现在主页上的评论统计是正确的了。</li>
<li>第三纯粹是个意外，我突然发现一年前的今天我搞了一个<a href="/todo-list/" title="Todo List">Todo list</a>。这个list上除了第一条之外我居然都完成了。这点让我非常开心。</li>
</ul>


<p>综上所述，心情好了就会来写博客了。</p>

<p>我还是有一个写作计划的。
<a href="https://class.coursera.org/compilers-selfservice/class" title="Compilers">Coursera上的Compiler</a>课程基本上学完了，要写心得体会；XFSd做完了也有很多话想说。把计划公布了就更有压力，希望我不会拖得太久。</p>

<p>好吧，按照惯例，我来回忆一下一年的生活。各位看官可以不用继续往下读了。请期待我另外的两篇文章吧。</p>

<!-- more -->


<hr />

<center>我最喜欢流水账了的分割线</center>


<hr />

<br/>


<p>这一年发生了很多事情，但是大部分都在计划之中。</p>

<p>十一月份滚回家，在家里一直看美剧，休息了两个月。（其实是我不记得除了看美剧我到底干什么了，又没有写日记，各大网站上都找不到自己的活动记录。）修改：我在家呆了几天就直接回学校了。在学校花了四个星期时间修满了学分，途中还写了这辈子第一个RPC——middleware，用的还是从来没用过的Ruby。在学校还接了现在的Offer，给自己电脑加了内存，修改了简历投了湾区各大公司（并在接下来的几个月里被搓）。找@icek内推了豆瓣并拿到Offer（然后发现时间错不开拒掉了）。</p>

<p>这样就到了元旦。我在元旦这一天坐上了回家的火车，开始了漫长的寒假。寒假基本贡献给了Cousera上的Compiler作业（和搜狐上的美剧）。这点可以从<a href="https://github.com/ditsing/compiler" title="Compiler">Github</a>上的<a href="https://github.com/ditsing/compiler/commits/master" title="Commits">commit</a>纪录看出来。当然我也参加了好多场TopCoder，其中大部分以暴跌收场。看我的人生这么艰难大家就不要拆穿我了。</p>

<p>开学了之后我的主要活动就是Compiler和毕设了。在开始做毕设之后的很长一段时间里（长达一个月），我的主要活动还是集中在Compiler的作业上。主要原因是配置Windows驱动开发环境实在是太蛋疼了，我装了两台Win7一台Win8外加一个虚拟机才搞定。直到四月份毕业设计的中期检查dealine之前的一周，数量巨大的commits被提交到了我在Github的项目上。中期检查的时候disk image parser已经可以用了。</p>

<p>中期检查之后我的工作的重心移到了XFSd的Windows接口上。开发XFSd的流程可以用Compiling Error(CE)&ndash;>删代码->CE->删代码->CE－>加代码->CE->删代码->CE&hellip;&hellip;&hellip;.&ndash;>WA->WA->WA来概括。经过5月初的一阵疯狂开发，项目在功能上基本成型了，但是有一个很大的Bug没有解决——磁盘镜像里的文件不能用命令行复制，但是自己写程序可以读出来。我花了很大精力来找这个bug的原因，但是直到毕设答辩也没找到。不过最后我还是fix了这个bug，但已经忘了是怎么fix的了。有些当时非常在意的事情，过了一段时间之后会发现也不过如此。</p>

<p>五月份六月份初这一段时间，我又回过头去写了Compiler的第三个作业。作业有判分脚本，用各种case测试程序。刷分的感觉跟刷题差不多，过程非常开心。而且这一段我一直在家，狠狠地享受了一把生活。</p>

<p>六月末七月初呢，毕设和论文时间。印象中我没有花多久在学习上面。很怀念我们班同学连续一周的疯狂聚餐。</p>

<p>之后是另外两个半月安逸的生活。安逸之中突然得知办签证要考雅思，匆匆准备了之后就在八月中旬参加了考试，成绩还算可以接受。接下来又经历了很多很多办签证流程。不过我的签证格外给力，所有材料提交之后四天就被批准了。拿到了签证之后我终于想到要做点实事了，于是把Compiler的最后一个作业刷到了满分，并且看完了所有的教学视频。现在计划把小作业和Quiz都刷完之后写总结。</p>

<p>最后就是刚刚过完的十月了。周末再来一篇文章写写搬家到悉尼的见闻。挖了好多坑啊。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[接近尾声：Facebook又三周]]></title>
    <link href="http://ditsing.com/blog/2012/11/11/jie-jin-wei-sheng-%3Afacebookyou-san-zhou/"/>
    <updated>2012-11-11T21:57:00+11:00</updated>
    <id>http://ditsing.com/blog/2012/11/11/jie-jin-wei-sheng-:facebookyou-san-zhou</id>
    <content type="html"><![CDATA[<p>第九，第十，第十一周。今晚是我本周唯一一个过了九点还不困的晚上。</p>

<ol>
<li>第九周本来是应该开始新工作的，结果却一直在对旧工作修修补补。新工作进展不错，雏形已经出来了。</li>
<li>第十周没有什么实质性的进展，尝试做了一个工具。实验发现工具的效果不太稳定，跟预想有很大误差。Mentor认为我没办法处理这个问题，于是让我先放下了。真正扫尾的时间到了。</li>
<li>第十一周扫尾，完成我一直在挂念的任务——重构那个巨丑无比的旧代码。为了搞清楚它的逻辑我真是脑袋都大了。让我重新开发估计也就一天就能搞定。事实上我确实重新开发了几乎所有重要的部分。800余行代码里连续没有改动的行数最大值小于13。</li>
</ol>


<p>这次没有心情再写流水账了。之前写是因为觉得这段时间很重要，发生的每件事情都要记下来。现在觉得不一样了，没有什么事情很重要。认真去生活，认真去思考，认真去品味。这就够了，犯不着大动干戈。
临近离开反而心如止水，没有思前想后的犹豫，没有患得患失的顾虑。在Facebook可以为未来奋斗，回到哈尔滨的也可以。</p>

<p>只可惜&hellip;</p>

<p>必须说，这将是一段珍贵的记忆。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一些想法：FB七八周]]></title>
    <link href="http://ditsing.com/blog/2012/10/21/yi-xie-xiang-fa-%3Afbqi-ba-zhou/"/>
    <updated>2012-10-21T22:05:00+11:00</updated>
    <id>http://ditsing.com/blog/2012/10/21/yi-xie-xiang-fa-:fbqi-ba-zhou</id>
    <content type="html"><![CDATA[<p>首先恭喜HIT_Encore拿下今年第一枚金牌，我死也瞑目了。今年注定是ACM@HIT丰收的一年，加油！</p>

<p>时间过的真快，在FB的第七第八周也结束了。这两周没有什么remarkable的工作：做幻灯片，修修补补加功能。基本都是在耍小聪明，没什么可以写的。</p>

<p>那就写写其他的。这两周我对未来的打算波动很大。</p>

<p>第七周之前我一直很坚定的要工作不要读书，但是第七周这个信念就动摇了。前几周碰到的所有同事几乎都是PhD，没有个学位真的不好意思跟他们打招呼。
给我的感觉就是没有PhD可能在Facebook不太好混。第七周的时候跟几个同事聊了聊这个想法，他们都说要是愿意申可以申一个，还不是太晚。于是我就心动了，觉得反正申一申也不费什么力气。只是我还缺
一个托福成绩，得找个时间把托福考了。一想到准备考试我就头大，何况这还是个考口语的考试。纠结。</p>

<p>第七周周四跟大馒头进行了中期总结，中间又被狠狠的打击了一次。确实，一没学分二没背景三没知识，靠什么号称自己excellent？所以我在G+上感叹说一切都来的太早。再给我半年时间，潜心修炼，什么都有了。</p>

<p>所以，还是去申个学校吧。周五去Google的路上又跟同事讨论了一番，明白了master和phd的区别。这样，申个学校的想法就在我脑子里深深的扎根了。一直在想什么时候去考托福，怎么考，怎么准备。
第八周一开始我就觉得应该选点有挑战的学校投，否则跟Facebook的offer比根本没有竞争力。但是就我这GPA，选这些学校太容易悲剧了。再想想还要跟教授陶瓷，真心觉得压力大：说都不会话。</p>

<p>到了周三，我又动摇了。费这么大力气只是给自己增加了一个不那么理想的选择，有必要吗？一会儿想，投一个也不费事，说不定会突然想体验一下新的生活；一会儿又想，直接工作多easy，申到学校也不会去的。<strong> 毕竟科研并不是我最想要的。</strong></p>

<p>真正让我放弃这个想法的是周四早上跟涛哥聊的天。他跟我描述了一下PhD的日常工作。我坐下来想了好久，觉得也不是非要去体验一下那种生活。可能是最近的工作比较有乐趣，比较有成就感，所以找第二条路的需求就淡了。</p>

<p>周六本来要去Sail的，起了个大早却错过了班车。于是又在家宅了一天，看电影看公开课，思考人生。</p>

<p>周日也是这样。周日晚上我室友回来了，我尝试跟他提了一下这个问题。他的看法很简单，如果我最终还是要工作的话，最多需要去读一个master。master才是我所谓的“学”东西，PhD是专心搞研究。而且，如果觉得自己的知识储备还不够，那我应该在工作之余Self Studying。Self Studying对我来说不是问题，花的时间可能会长一点，努力可能会多一点，我肯定还是可以学会的。再说现在还有Coursea这种神器，真的不用想那么多。</p>

<p>其实我现在还在纠结中，很纠结。这种事情吧，除非做了决定，否则肯定不知道哪个是更好的选择。</p>

<p>列一下想做的事情（已经copy至<a href="/todo-list/">Todo List</a>）：</p>

<ol>
<li>把具体数学和组合数学看完</li>
<li>在Coursea上一门Compiler的课，自己写一个Compiler</li>
<li>复习形式语言与自动机</li>
<li>把xfsd的项目做完</li>
<li>把N年前下的公开课看了</li>
<li>未完待续，想到了再补充，太长了就单开个页面</li>
</ol>


<p>流水账在下面，除了我应该没人能看懂。</p>

<!-- more -->


<ol>
<li>第七周周四：读代码，跟大馒头1v1开会，抱怨了前端工作的无聊。馒头很nice，问，你在哪些方面有经验？我可以帮你介绍Facebook的其他组。语塞。真心没有。没有还混什么混，老老实实当前端去！
晚上去Google吃饭，碰到了楼爷。大家不要问我楼爷现在在哪儿，我不会告诉你们的。</li>
<li>第七周周五：跟HR的Midterm，很顺利。中间谈到签证的问题，我问，要是我必须回国服务两年怎么办？HR说，我们可以等到你能过来的时候再说。轻松了许多啊</li>
<li>第七周周六：白天上午睡觉了，下午徒步出去走了走，到downtown吃了点东西，看喷泉听街头艺人的音乐。心里很安静。晚上到同事家一起玩儿跟杀人游戏类似的游戏。大家High到两点多。回来的路上跟组织活动的同事大概讨论了一下选校。</li>
<li>第七周周日：白天上午睡觉了。我发现我周末基本就是在家睡觉。下午去买菜，炒菜，蒸米饭，自己吃的挺happy。幻灯片太不好做了，纠结了很长时间。</li>
<li>第八周周一：中午跟大小mentor讨论了我的幻灯片，结论：惨不忍睹。他们点评之后我也觉得惨不忍睹。后来小馒头提了一个无比简洁的建议，这才好看了一点。晚上改幻灯片改到很晚。顺手做了点小修补。</li>
<li>第八周周二：馒头们都是好人呐，说换项目就换项目了。不用再做前端，改做后台一点的东西了。但是我上一周看的代码基本就白看了&hellip;..让我交个片段再换也好啊！</li>
<li>第八周周三：流程继续，修修补补。接受新项目，开始看手册、换着参数做试验。早上碰到一个之前一起开过会的同事，跟他讨论了下申请学校的问题，他就找导师给了我第一手的建议。</li>
<li>第八周周四：新项目有进展了，写了个Bash脚本跑跑数据。早上遇到了涛哥，讨论了很多。</li>
<li>第八周周五：完成了一个半成品，觉得进度很不错。</li>
<li>第八周周六：白天上午没睡觉，看电影了。下午买了点菜，给自己做了顿面条。煮的有点过了。晚上去同事家看电影——《穆赫兰道》，看到两点。晚上艰难的入睡了。</li>
<li>第八周周日：宅在家里一整天，一整天。苦思未来。晚上跟Cornell室友聊了聊，接受了建议。还是这个问题：假如最后我一定要进入工业界，为什么要走弯路去留学呢？</li>
</ol>


<hr />

<h2>Appended At 10.22</h2>

<ol>
<li>第九周周一：上午浪了一上午，下午干活，稍微找到了点门路。加油吧亲！</li>
</ol>

]]></content>
  </entry>
  
</feed>
